<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Pattern Matching
stage: 1
contributors:
  - Daniel Rosenwasser
  - Jack Works
  - Jordan Harband
  - Mark Cohen
  - Ross Kirsling
  - Tab Atkins
</pre>
<style>
  emu-note[code] > .note {
    font-size: 0;
  }
  emu-note[code] > .note::before {
    content: "Example";
    font-size: 18px;
  }
  emu-note[code] pre {
    margin: 0;
  }
  pre.inline {
    display: inline;
  }
  pre.inline code {
    display: inline;
    font-style: italic;
    text-decoration: underline;
  }
  body.folded .fold {
    display: none;
  }
</style>

<emu-clause id="welcome">
  <h1>Welcome</h1>
  <p>Work in progress. Before continuing, please read the <emu-xref href="#sec-notes" title></emu-xref>.</p>
  <p>Most of the trivia (built-in matchers) is folded. Some non-trivia sections you might be interested in:</p>
  <ul>
    <li><emu-xref title href="#sec-function.prototype-@@custommatcher"></emu-xref></li>
    <li><emu-xref title href="#sec-initializeinstance"></emu-xref></li>
    <li><emu-xref title href="#sec-runtime-semantics-classdefinitionevaluation"></emu-xref></li>
  </ul>
  <button id="expand">Click to expand the hidden sections.</button>
  <script defer async src="./assets/expand.js"></script>
</emu-clause>

<emu-clause class="fold" id="sec-ecmascript-data-types-and-values" aoid="Type" number="6">
  <h1>ECMAScript Data Types and Values</h1>
  <emu-clause id="sec-ecmascript-language-types">
    <h1>ECMAScript Language Types</h1>

    <emu-clause id="sec-ecmascript-language-types-symbol-type" number="5">
      <h1>The Symbol Type</h1>
      <emu-clause id="sec-well-known-symbols">
        <h1>Well-Known Symbols</h1>
        <emu-table id="table-1" caption="Well-known Symbols">
          <table>
            <tbody>
            <tr>
              <th>
                Specification Name
              </th>
              <th>
                [[Description]]
              </th>
              <th>
                Value and Purpose
              </th>
            </tr>
            <tr>
              <td>
                <ins><dfn>@@customMatcher</dfn></ins>
              </td>
              <td>
                <ins>`"Symbol.customMatcher"`</ins>
              </td>
              <td>
                <ins>A method that performs custom pattern matching semantics. Called by the semantics of the pattern matching features.</ins>
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
    <emu-clause id="sec-object-internal-methods-and-internal-slots" number="7">
      <h1>Object Internal Methods and Internal Slots</h1>
      <p><ins>All objects have an internal slot named [[ConstructedBy]], which is a List of ECMAScript language values. This List represents the origin of the object. Initially, it is an empty List.</ins></p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause class="fold" id="sec-abstract-operations" number="7">
  <h1>Abstract Operations</h1>
  <emu-clause id="sec-operations-on-objects" number="3">
    <h1>Operations on Objects</h1>
    <emu-clause oldids="sec-initializeinstanceelements" id="sec-initializeinstance" type="abstract operation" number="34">
      <h1>
        InitializeInstanceElements (
          _O_: an Object,
          _constructor_: an ECMAScript function object,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _methods_ be the value of _constructor_.[[PrivateMethods]].
        1. For each PrivateElement _method_ of _methods_, do
          1. Perform ? PrivateMethodOrAccessorAdd(_O_, _method_).
        1. Let _fields_ be the value of _constructor_.[[Fields]].
        1. For each element _fieldRecord_ of _fields_, do
          1. Perform ? DefineField(_O_, _fieldRecord_).
        1. <ins>Append _constructor_ to _O_.[[ConstructedBy]].</ins>
        1. Return ~unused~.
      </emu-alg>
      <emu-note type="editor">Rename this abstract operation to <dfn>InitializeInstance</dfn>.</emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause class="fold" id="sec-executable-code-and-execution-contexts" number="9">
  <h1>Executable Code and Execution Contexts</h1>
  <emu-clause id="sec-weakly-hold-targets-processing-model" oldids="sec-weakref-processing-model" number="10">
    <h1>Processing Model of <del>WeakRef and FinalizationRegistry</del><ins>weakly hold</ins> Targets</h1>
    <emu-clause id="sec-weakly-hold-execution" oldids="sec-weakref-execution" number="3">
      <h1>Execution</h1>

      <p>At any time, if a set of objects and/or symbols _S_ is not live, an ECMAScript implementation may perform the following steps atomically:</p>

      <emu-alg>
        1. For each element _value_ of _S_, do
          1. For each WeakRef _ref_ such that _ref_.[[WeakRefTarget]] is _value_, do
            1. Set _ref_.[[WeakRefTarget]] to ~empty~.
          1. For each FinalizationRegistry _fg_ such that _fg_.[[Cells]] contains a Record _cell_ such that _cell_.[[WeakRefTarget]] is _value_, do
            1. Set _cell_.[[WeakRefTarget]] to ~empty~.
            1. Optionally, perform HostEnqueueFinalizationRegistryCleanupJob(_fg_).
          1. For each WeakMap _map_ such that _map_.[[WeakMapData]] contains a Record _r_ such that _r_.[[Key]] is _value_, do
            1. Set _r_.[[Key]] to ~empty~.
            1. Set _r_.[[Value]] to ~empty~.
          1. For each WeakSet _set_ such that _set_.[[WeakSetData]] contains _value_, do
            1. Replace the element of _set_.[[WeakSetData]] whose value is _value_ with an element whose value is ~empty~.
          1. <ins>For each Object _o_ such that _o_.[[ConstructedBy]] contains _value_, do</ins>
            1. <ins>Remove _value_ from _o_.[[ConstructedBy]].</ins>
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-expressions" number="13">
  <h1>ECMAScript Language: Expressions</h1>
  <emu-clause id="sec-relational-operators" number="10">
    <h1>Relational Operators</h1>
    <h2>Syntax</h2>
    <emu-grammar>
      RelationalExpression[In, Yield, Await] :
        <ins>RelationalExpression [no LineTerminator here] `is` MatchPattern</ins>
    </emu-grammar>
    <emu-clause id="sec-relational-operators-runtime-semantics-evaluation" number="1">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>
        <ins>RelationalExpression : RelationalExpression `is` MatchPattern</ins>
      </emu-grammar>
      <emu-alg>
        1. Let _lref_ be ? Evaluation of |RelationalExpression|.
        1. Let _lval_ be ? GetValue(_lref_).
        1. Return ? MatchPatternMatches of |MatchPattern| with argument _lval_.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause class="fold" id="sec-ecmascript-language-functions-and-classes" number="15">
  <h1>ECMAScript Language: Functions and Classes</h1>
  <emu-clause id="sec-class-definitions" number="7">
    <h1>Class Definitions</h1>
    <emu-clause id="sec-runtime-semantics-classdefinitionevaluation" type="sdo" number="14">
      <h1>
        Runtime Semantics: ClassDefinitionEvaluation (
          _classBinding_: a String or *undefined*,
          _className_: a property key or a Private Name,
        ): either a normal completion containing a function object or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-note type="editor">See <a href="https://github.com/tc39/ecma262/pull/3212/files" target="_blank">Editorial: call MakeClassConstructor on default class constructor</a>.</emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause class="fold" id="sec-fundamental-objects" number="20">
  <h1>Fundamental Objects</h1>
  <emu-clause id="sec-object-objects" number="1">
    <h1>Object Objects</h1>
    <emu-clause id="sec-properties-of-the-object-constructor" number="2">
      <h1>Properties of the Object Constructor</h1>
      <emu-clause id="sec-object-@@custommatcher" number="24">
        <h1>Object [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_, ~boolean~).
          1. If _subject_ is not an Object, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-function-objects" number="2">
    <h1>Function Objects</h1>
    <emu-clause id="sec-properties-of-the-function-constructor" number="2">
      <h1>Properties of the Function Constructor</h1>
      <emu-clause id="sec-function-@@custommatcher" number="2">
        <h1>Function [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_, ~boolean~).
          1. Return IsCallable(_subject_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
    <emu-clause id="sec-properties-of-the-function-prototype-object" number="3">
      <h1>Properties of the Function Prototype Object</h1>
      <emu-clause id="sec-function.prototype-@@custommatcher" number="7">
        <h1>Function.prototype [ @@customMatcher ] ( _subject_, _hint_, _receiver_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_).
          1. Let _func_ be the *this* value.
          1. If IsCallable(_func_) is false, throw a *TypeError* exception.
          1. If _subject_.[[ConstructedBy]] contains _func_, return *true*.
          1. If _func_ does not have a [[IsClassConstructor]] internal slot or _func_.[[IsClassConstructor]] is *false*, return ? Call(_func_, _receiver_, « _subject_, _hint_ »).
          1. Return *false*.
        </emu-alg>
        <emu-note code>
          <pre><code class="javascript">
            class C {}
            c is C; // true, by private-field semantics

            function f() {}
            class F extends f {}
            const i = new F();
            i is F; // true, by private-field semantics
            i is f; // true, by private-field semantics even if f is a normal function

            expr is Array.isArray; // true, by Array.isArray(expr)
          </code></pre>
        </emu-note>
        <emu-note type="editor">
          Not every champion group agrees with private-field-like brand check semantics.
          There are
          <a href="https://github.com/tc39/proposal-pattern-matching/pull/293#issuecomment-1725097699" target="_blank">performance concerns</a>,
          <a href="https://github.com/tc39/proposal-pattern-matching/pull/293#issuecomment-1725097699" target="_blank">"hackable" concerns</a>, and
          <a href="https://github.com/tc39/proposal-pattern-matching/pull/293#issuecomment-1725097699" target="_blank">interaction with @@hasInstance concerns</a>.
          Another approach is to use `instanceof` semantics.
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-boolean-objects" number="3">
    <h1>Boolean Objects</h1>
    <emu-clause id="sec-properties-of-the-boolean-constructor" number="2">
      <h1>Properties of the Boolean Constructor</h1>
      <emu-clause id="sec-boolean-@@custommatcher" number="2">
        <h1>Boolean [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_).
          1. If _subject_ is not a Boolean and does not have a [[BooleanData]] internal slot, return *false*.
          1. If _hint_ is *"boolean"*, return *true*.
          1. If _subject_ is a Boolean, return CreateArrayFromList(« _subject_ »).
          1. Return CreateArrayFromList(« _subject_.[[BooleanData]] »).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-symbol-objects" number="4">
    <h1>Symbol Objects</h1>
    <emu-clause id="sec-properties-of-the-symbol-constructor" number="2">
      <h1>Properties of the Symbol Constructor</h1>
      <emu-clause id="sec-symbol.custommatcher" number="17">
        <h1>Symbol.customMatcher</h1>
        <p>The initial value of `Symbol.customMatcher` is the well-known symbol @@customMatcher (<emu-xref href="#table-well-known-symbols"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
      <emu-clause id="sec-symbol-@@custommatcher">
        <h1>Symbol [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_).
          1. If _subject_ is not a Symbol and does not have a [[SymbolData]] internal slot, return *false*.
          1. If _hint_ is *"boolean"*, return *true*.
          1. If _subject_ is a Symbol, return CreateArrayFromList(« _subject_ »).
          1. Return CreateArrayFromList(« _subject_.[[SymbolData]] »).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-error-objects" number="5">
    <h1>Error Objects</h1>
    <emu-clause id="sec-error-constructor" number="1">
      <h1>The Error Constructor</h1>
      <emu-clause id="sec-error-message">
        <h1>Error ( _message_ [ , _options_ ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.
          1. Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Error.prototype%"*, « [[ErrorData]] »).
          1. <ins>Set _O_.[[ErrorData]] to *"Error"*.</ins>
          1. If _message_ is not *undefined*, then
            1. Let _msg_ be ? ToString(_message_).
            1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *"message"*, _msg_).
          1. Perform ? InstallErrorCause(_O_, _options_).
          1. Return _O_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-error-constructors" number="2">
      <h1>Properties of the Error Constructor</h1>
      <emu-clause id="sec-error-@@custommatcher" number="2">
          <h1>Error [ @@customMatcher ] ( _subject_, _hint_ )</h1>
          <p>This function performs the following steps when called:</p>
          <emu-alg>
            1. Perform ? ValidateCustomMatcherHint(_hint_, ~boolean~).
            1. If _subject_ does not have a [[ErrorData]] internal slot, return *false*.
            1. Return *true*.
          </emu-alg>
      </emu-clause>
      <emu-note type="editor">
        It's possible to provide extractor semantics for Error custom matchers.
        <pre><code class="javascript">
          when Error(let message, { let cause? }): ...,
        </code></pre>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-properties-of-error-instances" number="4">
      <h1>Properties of Error Instances</h1>
      <p>Error instances are ordinary objects that inherit properties from the Error prototype object and have an [[ErrorData]] internal slot whose value is <del>*undefined*</del> <ins>a String</ins>. The only specified uses of [[ErrorData]] is to identify Error, AggregateError, and _NativeError_ instances as Error objects within `Object.prototype.toString` <ins>and their @@customMatcher methods</ins>.</p>
      <emu-note type="editor">
        Maybe rename this internal slot to [[ErrorKind]].
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-nativeerror-object-structure" number="6">
      <h1>_NativeError_ Object Structure</h1>
      <emu-clause id="sec-nativeerror-constructors" number="1">
        <h1>The _NativeError_ Constructors</h1>
        <emu-clause id="sec-nativeerror" number="1">
          <h1>_NativeError_ ( _message_ [ , _options_ ] )</h1>
          <p>Each _NativeError_ function performs the following steps when called:</p>
          <emu-alg>
            1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.
            1. Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, <code>"%<var>NativeError</var>.prototype%"</code>, « [[ErrorData]] »).
            1. <ins>Set _O_.[[ErrorData]] to _NativeError_.</ins>
            1. If _message_ is not *undefined*, then
              1. Let _msg_ be ? ToString(_message_).
              1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *"message"*, _msg_).
            1. Perform ? InstallErrorCause(_O_, _options_).
            1. Return _O_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-nativeerror-constructors" number="2">
        <h1>Properties of the _NativeError_ Constructors</h1>
        <emu-clause id="sec-nativeerror-@@custommatcher" number="2">
          <h1>_NativeError_ [ @@customMatcher ] ( _subject_, _hint_ )</h1>
          <emu-alg>
            1. Perform ? ValidateCustomMatcherHint(_hint_, ~boolean~).
            1. If _subject_ does not have a [[ErrorData]] internal slot or _subject_.[[ErrorData]] is not _NativeError_, return *false*.
            1. Return *true*.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-nativeerror-instances" number="4">
        <h1>Properties of _NativeError_ Instances</h1>
        <p>_NativeError_ instances are ordinary objects that inherit properties from their _NativeError_ prototype object and have an [[ErrorData]] internal slot whose value is <del>*undefined*</del> <ins>a String</ins>. The only specified use of [[ErrorData]] is by `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>) <ins>and their @@customMatcher methods</ins> to identify Error, AggregateError, or _NativeError_ instances.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-aggregate-error-objects" number="7">
      <h1>AggregateError Objects</h1>
      <emu-clause id="sec-aggregate-error-constructor" number="1">
        <h1>The AggregateError Constructor</h1>
        <emu-clause id="sec-aggregate-error">
          <h1>AggregateError ( _errors_, _message_ [ , _options_ ] )</h1>
          <p>This function performs the following steps when called:</p>
          <emu-alg>
            1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.
            1. Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%AggregateError.prototype%"*, « [[ErrorData]] »).
            1. <ins>Set _O_.[[ErrorData]] to *"AggregateError"*.</ins>
            1. If _message_ is not *undefined*, then
              1. Let _msg_ be ? ToString(_message_).
              1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *"message"*, _msg_).
            1. Perform ? InstallErrorCause(_O_, _options_).
            1. Let _errorsList_ be ? IteratorToList(? GetIterator(_errors_, ~sync~)).
            1. Perform ! DefinePropertyOrThrow(_O_, *"errors"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errorsList_) }).
            1. Return _O_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-aggregate-error-constructors" number="2">
        <h1>Properties of the AggregateError Constructor</h1>
        <emu-clause id="sec-aggregate-error-@@custommatcher" number="2">
          <h1>AggregateError [ @@customMatcher ] ( _subject_, _hint_ )</h1>
          <emu-alg>
            1. Perform ? ValidateCustomMatcherHint(_hint_, ~boolean~).
            1. If _subject_ does not have a [[ErrorData]] internal slot or _subject_.[[ErrorData]] is not *"AggregateError"*, return *false*.
            1. Return *true*.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-aggregate-error-instances" number="4">
        <h1>Properties of AggregateError Instances</h1>
        <p>AggregateError instances are ordinary objects that inherit properties from their AggregateError prototype object and have an [[ErrorData]] internal slot whose value is <del>*undefined*</del> <ins>a String</ins>. The only specified use of [[ErrorData]] is by `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>) <ins>and their @@customMatcher methods</ins> to identify Error, AggregateError, or _NativeError_ instances.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause class="fold" id="sec-numbers-and-dates" number="21">
  <h1>Numbers and Dates</h1>
  <emu-clause id="sec-number-objects" number="1">
    <h1>Number Objects</h1>
    <emu-clause id="sec-properties-of-the-number-constructor" number="2">
      <h1>Properties of the Number Constructor</h1>
      <emu-clause id="sec-number-@@custommatcher" number="16">
        <h1>Number [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_).
          1. If _subject_ is not a Number and does not have a [[NumberData]] internal slot, return *false*.
          1. If _hint_ is *"boolean"*, return *true*.
          1. If _subject_ is a Number, return CreateArrayFromList(« _subject_ »).
          1. Return CreateArrayFromList(« _subject_.[[NumberData]] »).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-bigint-objects" number="2">
    <h1>BigInt Objects</h1>
    <emu-clause id="sec-properties-of-the-bigint-constructor" number="2">
      <h1>Properties of the BigInt Constructor</h1>
      <emu-clause id="sec-bigint-@@custommatcher" number="4">
        <h1>BigInt [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_).
          1. If _subject_ is not a BigInt and does not have a [[BigIntData]] internal slot, return *false*.
          1. If _hint_ is *"boolean"*, return *true*.
          1. If _subject_ is a BigInt, return CreateArrayFromList(« _subject_ »).
          1. Return CreateArrayFromList(« _subject_.[[BigIntData]] »).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-date-objects" number="4">
    <h1>Date Objects</h1>
    <emu-clause id="sec-properties-of-the-date-constructor" number="3">
      <h1>Properties of the Date Constructor</h1>
      <emu-clause id="sec-date-@@custommatcher" number="5">
        <h1>Date [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_, ~boolean~).
          1. If _subject_ does not have a [[DateValue]] internal slot, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause class="fold" id="sec-text-processing" number="22">
  <h1>Text Processing</h1>
  <emu-clause id="sec-string-objects" number="1">
    <h1>String Objects</h1>
    <emu-clause id="sec-properties-of-the-string-constructor" number="2">
      <h1>Properties of the String Constructor</h1>
      <emu-clause id="sec-string-@@custommatcher" number="5">
        <h1>String [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_).
          1. If _subject_ is not a String and does not have a [[StringData]] internal slot, return *false*.
          1. If _hint_ is *"boolean"*, return *true*.
          1. If _subject_ is a String, return CreateArrayFromList(« _subject_ »).
          1. Return CreateArrayFromList(« _subject_.[[StringData]] »).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-regexp-regular-expression-objects" number="2">
    <h1>RegExp (Regular Expression) Objects</h1>
    <emu-clause id="sec-properties-of-the-regexp-constructor" number="5">
      <h1>Properties of the RegExp Constructor</h1>
      <emu-clause id="sec-regexp-@@custommatcher" number="3">
        <h1>RegExp [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_, ~boolean~).
          1. If ? IsRegExp(_subject_) is *false*, return *false*.
          1. Return *true*.
        </emu-alg>
        <emu-note>
          IsRegExp returns *true* for objects that have a truthy @@match property. Do we want that?
        </emu-note>
      </emu-clause>
    </emu-clause>
    <emu-clause id="sec-properties-of-the-regexp-prototype-object" number="6">
      <h1>Properties of the RegExp Prototype Object</h1>
      <emu-clause id="sec-regexp.prototype-@@custommatcher" number="20">
        <h1>RegExp.prototype [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_, ~boolean~).
          1. Let _regexp_ be *this* value.
          1. If _hint_ is *"boolean"*, return ? Call(%RegExp.prototype.test%, _regexp_, « _subject_ »).
          1. Let _isRegExp_ be ? IsRegExp(_regexp_).
          1. If _isRegExp_ is *true*, then
            1. Let _flags_ be ? Get(_regexp_, "flags").
            1. Perform ? RequireObjectCoercible(_flags_).
            1. If ? ToString(_flags_) contain *"g"*, return ? Call(%String.prototype.matchAll%, _subject_, « _regexp_ »).
          1. Let _result_ be ? Call(%String.prototype.match%, _subject_, « _regexp_ »).
          1. Return CreateArrayFromList(« _result_ »).
        </emu-alg>
        <emu-note code>
          <pre><code class="javascript">
            let regex = /(?&lt;id&gt;\d+)-?/g
            '012-345' is regex(["012-", "012"], { groups: { id: "345" } });
            // true, match with matchAll

            let regex2 = /(?&lt;id&gt;\d+)-?/
            '012-345' is regex({ groups: { id: "012" } });
            // true, match with match
          </code></pre>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause class="fold" id="sec-indexed-collections" number="23">
  <h1>Indexed Collections</h1>
  <emu-clause id="sec-array-objects" number="1">
    <h1>Array Objects</h1>
    <emu-clause id="sec-properties-of-the-array-constructor" number="2">
      <h1>Properties of the Array Constructor</h1>
      <emu-clause id="sec-array-@@custommatcher" number="6">
        <h1>Array [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_).
          1. If ? IsArray(_subject_) is *false*, return *false*.
          1. If _hint_ is *"boolean"*, return *true*.
          1. Return _subject_.
        </emu-alg>
        <emu-note code>
          <pre><code class="javascript">
            expr is Array(1, 2, 3, 4);
          </code></pre>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-typedarray-objects" number="2">
    <h1>TypedArray Objects</h1>
    <emu-clause id="sec-properties-of-the-typedarray-constructors" number="6">
      <h1>Properties of the _TypedArray_ Constructors</h1>
      <emu-clause id="sec-_typedarray_-@@custommatcher" number="3">
        <h1>_TypedArray_ [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_).
          1. If _subject_ does not have a [[TypedArrayName]] internal slot or _subject_.[[TypedArrayName]] is not _TypedArray_, return *false*.
          1. If _hint_ is *"boolean"*, return *true*.
          1. Return _subject_.
        </emu-alg>
        <emu-note code>
          <pre><code class="javascript">
            const isPNG = binary is Uint8Array(
              0x89, 0x50, 0x4E, 0x47,
              0x0D, 0x0A, 0x1A, 0x0A, ...
            ); // the ... is necessary otherwise it will only match a length-8 binary.
          </code></pre>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause class="fold" id="sec-keyed-collections" number="24">
  <h1>Keyed Collections</h1>
  <emu-clause id="sec-map-objects" number="1">
    <h1>Map Objects</h1>
    <emu-clause id="sec-properties-of-the-map-constructor" number="2">
      <h1>Properties of the Map Constructor</h1>
      <emu-clause id="sec-map-@@custommatcher" number="3">
        <h1>Map [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_).
          1. If _subject_ does not have a [[MapData]] internal slot, return *false*.
          1. If _hint_ is *"boolean"*, return *true*.
          1. Return CreateArrayFromList(« _subject_ »).
        </emu-alg>
        <emu-note code>
          <pre><code class="javascript">
            expr is Map([[1, 2], [3, 4]]);
            // matches new Map([[1, 2], [3, 4]])
            // but not new Map([[3, 4], [1, 2]])
          </code></pre>
        </emu-note>
        <emu-note type="editor">
          A Map can be iterated, but is it meaningful to do so in pattern matching?
          Because <pre class="inline"><code class="javascript">x is Map([[a, b], [c, d]])</code></pre> is an ordered match.
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-set-objects" number="2">
    <h1>Set Objects</h1>
    <emu-clause id="sec-properties-of-the-set-constructor" number="2">
      <h1>Properties of the Set Constructor</h1>
      <emu-clause id="sec-set-@@custommatcher" number="3">
        <h1>Set [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_).
          1. If _subject_ does not have a [[SetData]] internal slot, return *false*.
          1. If _hint_ is *"boolean"*, return *true*.
          1. Return CreateArrayFromList(« _subject_ »).
        </emu-alg>
        <emu-note code>
          <pre><code class="javascript">
            expr is Set([1, 2, 3]);
            // matches new Set([1, 2, 3])
            // but not new Set([3, 2, 1])
          </code></pre>
        </emu-note>
        <emu-note type="editor">
          A Set can be iterated, but is it meaningful to do so in pattern matching?
          Because <pre class="inline"><code class="javascript">x is Set(a, b, c, d)</code></pre> is an ordered match.
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-weakmap-objects" number="3">
    <h1>WeakMap Objects</h1>
    <emu-clause id="sec-properties-of-the-weakmap-constructor" number="2">
      <h1>Properties of the WeakMap Constructor</h1>
      <emu-clause id="sec-weakmap-@@custommatcher" number="2">
        <h1>WeakMap [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_, ~boolean~).
          1. If _subject_ does not have a [[WeakMapData]] internal slot, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-weakset-objects" number="4">
    <h1>WeakSet Objects</h1>
    <emu-clause id="sec-properties-of-the-weakset-constructor" number="2">
      <h1>Properties of the WeakSet Constructor</h1>
      <emu-clause id="sec-weakset-@@custommatcher" number="2">
        <h1>WeakSet [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_, ~boolean~).
          1. If _subject_ does not have a [[WeakSetData]] internal slot, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause class="fold" id="sec-structured-data" number="25">
  <h1>Structured Data</h1>
  <emu-clause id="sec-arraybuffer-objects" number="1">
    <h1>ArrayBuffer Objects</h1>
    <emu-clause id="sec-properties-of-the-arraybuffer-constructor" number="5">
      <h1>Properties of the ArrayBuffer Constructor</h1>
      <emu-clause id="sec-arraybuffer-@@custommatcher" number="4">
        <h1>ArrayBuffer [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_, ~boolean~).
          1. If _subject_ has a [[ArrayBufferData]] internal slot, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-sharedarraybuffer-objects" number="2">
    <h1>SharedArrayBuffer Objects</h1>
    <emu-clause id="sec-properties-of-the-sharedarraybuffer-constructor" number="4">
      <h1>Properties of the SharedArrayBuffer Constructor</h1>
      <emu-clause id="sec-sharedarraybuffer-@@custommatcher" number="3">
        <h1>SharedArrayBuffer [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_, ~boolean~).
          1. If _subject_ does not have a [[ArrayBufferData]] internal slot, return *false*.
          1. Return IsSharedArrayBuffer(_subject_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-dataview-objects" number="3">
    <h1>DataView Objects</h1>
    <emu-clause id="sec-properties-of-the-dataview-constructor" number="3">
      <h1>Properties of the DataView Constructor</h1>
      <emu-clause id="sec-dataview-@@custommatcher" number="2">
        <h1>DataView [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_, ~boolean~).
          1. If _subject_ does not have a [[DataView]] internal slot, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause class="fold" id="sec-managing-memory" number="26">
  <h1>Managing Memory</h1>
  <emu-clause id="sec-weak-ref-objects" number="1">
    <h1>WeakRef Objects</h1>
    <emu-clause id="sec-properties-of-the-weak-ref-constructor" number="2">
      <h1>Properties of the WeakRef Constructor</h1>
      <emu-clause id="sec-weakref-@@custommatcher" number="2">
        <h1>WeakRef [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_).
          1. If _subject_ does not have a [[WeakRefTarget]] internal slot, return *false*.
          1. If _hint_ is *"boolean"*, return *true*.
          1. Return CreateArrayFromList(« WeakRefDeref(_subject_) »).
        </emu-alg>
        <emu-note code>
          <pre><code class="javascript">
            expr is WeakRef({ type: 1 });
          </code></pre>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-finalization-registry-objects" number="2">
    <h1>FinalizationRegistry Objects</h1>
    <emu-clause id="sec-properties-of-the-finalization-registry-constructor" number="2">
      <h1>Properties of the FinalizationRegistry Constructor</h1>
      <emu-clause id="sec-finalizationregistry-@@custommatcher" number="2">
        <h1>FinalizationRegistry [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_, ~boolean~).
          1. If _subject_ does not have a [[CleanupCallback]] internal slot, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause class="fold" id="sec-control-abstraction-objects" number="27">
  <h1>Control Abstraction Objects</h1>
  <emu-clause id="sec-promise-objects" number="2">
    <h1>Promise Objects</h1>
    <emu-clause id="sec-properties-of-the-promise-constructor" number="4">
      <h1>Properties of the Promise Constructor</h1>
      <emu-clause id="sec-promise-@@custommatcher" number="9">
        <h1>Promise [ @@customMatcher ] ( _subject_, _hint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? ValidateCustomMatcherHint(_hint_, ~boolean~).
          1. Return IsPromise(_subject_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause class="fold" id="sec-reflection" number="28">
  <h1>Reflection</h1>
  <emu-clause id="sec-proxy-objects" number="2">
    <h1>Proxy Objects</h1>
    <emu-clause id="sec-proxy-constructor" number="1">
      <h1>The Proxy Constructor</h1>
      <emu-clause id="sec-proxy-@@custommatcher" number="2">
        <h1>Proxy [ @@customMatcher ] ( )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Throw a *TypeError* exception.
        </emu-alg>
      </emu-clause>
      <emu-note type="editor">
        All built-in constructors have a @@customMatcher method. This one is for the design consistency.<br />
        This is not a consensus in the champion group.
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-pattern-matching" number="30">
  <h1><ins>Pattern Matching</ins></h1>

  <emu-clause id="sec-match-patterns">
    <h1>Match Patterns</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      MatchPattern[Yield, Await] :
        `(` MatchPattern[?Yield, ?Await] `)`
        PrimitivePattern
        MemberExpressionPattern[?Yield, ?Await]
        UnaryAlgebraicPattern[?Yield, ?Await]
        IfPattern[?Yield, ?Await]
        CombinedMatchPattern[?Yield, ?Await]
    </emu-grammar>

    <!-- #region PrimitivePattern -->
    <emu-grammar type="definition">
      PrimitivePattern :
        Literal
        NoSubstitutionTemplate
    </emu-grammar>
    <emu-note code>
      <pre><code class="javascript">
        value is null;
        value is true;
        value is 1_000_000;
        value is "string";
        value is `line 1
        line 2`;
      </code></pre>
    </emu-note>
    <emu-note type="editor">
      Preserve the interpolation syntax for (1) <a href="https://github.com/tc39/proposal-pattern-matching/pull/293#discussion_r1350757767" target="_blank">concerns about arbitrary expression interpolation</a> and (2) <a target="_blank" href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#inference-with-template-literals">intuitive string matching</a>.
      For example, match `"com.example:method()"` by
      <pre><code class="javascript">
        when `${isPackageName and let pkg}:${isIdentifier and let method}()`: ...,
      </code></pre>
    </emu-note>
    <!-- endregion -->

    <!-- #region MemberExpressionPattern -->
    <emu-grammar type="definition">
      MemberExpressionPattern[Yield, Await] :
        PatternMatchingMemberExpression[?Yield, ?Await]

      PatternMatchingMemberExpression[Yield, Await] :
        `this`
        MetaProperty
        IdentifierReference[?Yield, ?Await]
        `super` `.` IdentifierName
        PatternMatchingMemberExpression[?Yield, ?Await] `.` IdentifierName
        PatternMatchingMemberExpression[?Yield, ?Await] `?.` IdentifierName
        PatternMatchingMemberExpression[?Yield, ?Await] `.` PrivateIdentifier
        PatternMatchingMemberExpression[?Yield, ?Await] `?.` PrivateIdentifier
    </emu-grammar>
    <emu-note code>
      <pre><code class="javascript">
        value is undefined; value is Math.PI;
        value is this; value is obj.#priv;
        value is super.foo; value is import.meta.data?.value;
      </code></pre>
    </emu-note>
    <emu-note type="editor">
      All productions except |IdentifierReference| can be removed.
      <pre><code class="javascript">
        value is Math.PI;
        // can be written as:
        const { PI } = Math;
        value is PI;
      </code></pre>
      It is similar to the <a href="https://tc39.es/proposal-decorators/#sec-new-syntax" target="_blank">DecoratorMemberExpression</a>.<br />
      Should we allow `MemberExpressionPattern[expr]` to match with computed property names?
    </emu-note>
    <!-- endregion -->

    <!-- #region UnaryAlgebraicPattern -->
    <emu-grammar type="definition">
      UnaryAlgebraicPattern[Yield, Await] :
        `+` PatternMatchingMemberExpression[?Yield, ?Await]
        `-` PatternMatchingMemberExpression[?Yield, ?Await]
        `+` NumericLiteral
        `-` NumericLiteral
    </emu-grammar>
    <emu-note code>
      <pre><code class="javascript">
        value is -0; // not matching `+0` and vice versa
        value is -Infinity;
        value is -Math.PI;
      </code></pre>
    </emu-note>
    <emu-note type="editor">
      This production can be removed, but it will be harder to handle with `+0` and `-0`.
      <pre><code class="javascript">
        value is -Infinity;
        // can be written as:
        const negInf = -Infinity;
        value is negInf;
      </code></pre>
    </emu-note>
    <!-- endregion -->

    <!-- #region IfPattern -->
    <emu-grammar type="definition">
      IfPattern[Yield, Await] :
        `if` `(` Expression[+In, ?Yield, ?Await] `)`
    </emu-grammar>
    <emu-note code>
      <pre><code class="javascript">
        value is { prop: MyClass and if (value.someTest("foo")) };
      </code></pre>
    </emu-note>
    <emu-note type="editor">
      This production can be removed, but this is designed as an escape hatch.
    </emu-note>
    <!-- endregion -->

    <!-- #region CombinedMatchPattern -->
    <emu-grammar type="definition">
      CombinedMatchPattern[Yield, Await] :
        MatchPattern[?Yield, ?Await] `and` MatchPattern[?Yield, ?Await]
        MatchPattern[?Yield, ?Await] `or` MatchPattern[?Yield, ?Await]
        `not` MatchPattern[?Yield, ?Await]
    </emu-grammar>
    <emu-note code>
      <pre><code class="javascript">
        value is not 0;
        value is "true" or "yes";
      </code></pre>
    </emu-note>
    <!-- endregion -->

    <emu-clause id="sec-match-patterns-early-errors">
      <h1>Static Semantics: Early Errors</h1>

      <!-- #region CombinedMatchPattern -->
      <emu-grammar>
        CombinedMatchPattern :
          MatchPattern `and` MatchPattern
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if either of |MatchPattern| is |CombinedMatchPattern| and does not match this production.</li>
      </ul>
      <emu-grammar>
        CombinedMatchPattern :
          MatchPattern `or` MatchPattern
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if either of |MatchPattern| is |CombinedMatchPattern| and does not match this production.</li>
      </ul>
      <emu-grammar>
        CombinedMatchPattern :
          `not` MatchPattern
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if the |MatchPattern| is |CombinedMatchPattern|.</li>
      </ul>
      <emu-note code><pre><code class="javascript">
        value is a and b and c; // no Syntax Error
        value is a or b or c; // no Syntax Error

        value is a and b or c; // Syntax Error
        value is (a and b) or c; // no Syntax Error
        value is a and (b or c); // no Syntax Error

        value is not not a; // Syntax Error
        value is not (not a); // no Syntax Error

        value is not a or b; // Syntax Error
        value is not (a or b); // no Syntax Error
      </code></pre></emu-note>
      <!-- endregion -->
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-match-pattern-semantics">
    <h1>Match Pattern Semantics</h1>

    <emu-clause id="sec-match-pattern-matches" type="sdo">
      <h1>
        Runtime Semantics: MatchPatternMatches (
          _subject_: an ECMAScript language value,
        ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        MatchPattern : `(` MatchPattern `)`
      </emu-grammar>
      <emu-alg>
        1. Return ? MatchPatternMatches of |MatchPattern| with arguments _subject_.
      </emu-alg>
      <emu-grammar>
        MatchPattern : PrimitivePattern
      </emu-grammar>
      <emu-alg>
        1. Return PrimitivePatternMatches of |PrimitivePattern| with arguments _subject_.
      </emu-alg>
      <emu-grammar>
        MatchPattern : MemberExpressionPattern
      </emu-grammar>
      <emu-alg>
        1. Return ? MemberExpressionPatternMatches of |MemberExpressionPattern| with arguments _subject_.
      </emu-alg>
      <emu-grammar>
        MatchPattern : UnaryAlgebraicPattern
      </emu-grammar>
      <emu-alg>
        1. Return ? UnaryAlgebraicPatternMatches of |UnaryAlgebraicPattern| with arguments _subject_.
      </emu-alg>
      <emu-grammar>
        MatchPattern : IfPattern
      </emu-grammar>
      <emu-alg>
        1. Return ? IfPatternMatches of |IfPattern|.
      </emu-alg>
      <emu-grammar>
        MatchPattern : CombinedMatchPattern
      </emu-grammar>
      <emu-alg>
        1. Return ? CombinedMatchPatternMatches of |CombinedMatchPattern| with arguments _subject_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-primitive-pattern-matches" type="sdo">
      <h1>
        Runtime Semantics: PrimitivePatternMatches (
          _subject_: an ECMAScript language value,
        ): a Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        PrimitivePattern : Literal
      </emu-grammar>
      <emu-alg>
        1. Return SameValueZero(_subject_, ! Evaluation of |Literal|).
      </emu-alg>
      <emu-grammar>
        PrimitivePattern : NoSubstitutionTemplate
      </emu-grammar>
      <emu-alg>
        1. Return SameValueNonNumber(_subject_, ! Evaluation of |NoSubstitutionTemplate|).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-member-expression-pattern-matches" type="sdo">
      <h1>
        Runtime Semantics: MemberExpressionPatternMatches (
          _subject_: an ECMAScript language value,
        ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        MemberExpressionPattern : PatternMatchingMemberExpression
      </emu-grammar>
      <emu-alg>
        1. Let _expr_ be the |LeftHandSideExpression| that is covered by |PatternMatchingMemberExpression|.
        1. Let _ref_ be ? Evaluation of _expr_.
        1. Let _value_ be ? GetValue(_ref_).
        1. If _ref_ is a Reference Record and IsPropertyReference(_ref_) is *true*, let _receiver_ be GetThisValue(_ref_).
        1. Else, let _receiver_ be *null*.
        1. Let _result_ be ? InvokeCustomMatcher(_value_, _subject_, ~boolean~, _receiver_).
        1. Assert: _result_ is a Boolean.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-unary-algebraic-pattern-matches" type="sdo">
      <h1>
        Runtime Semantics: UnaryAlgebraicPatternMatches (
          _subject_: an ECMAScript language value,
        ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        UnaryAlgebraicPattern
      </emu-grammar>
      <emu-alg>
        1. Let _expr_ be the |LeftHandSideExpression| that is covered by |UnaryAlgebraicPattern|.
        1. Let _ref_ be ? Evaluation of _expr_.
        1. Let _value_ be ? GetValue(_ref_).
        1. Return SameValue(_subject_, _value_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-if-pattern-matches" type="sdo">
      <h1>
        Runtime Semantics: IfPatternMatches ( ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        IfPattern : `if` `(` Expression `)`
      </emu-grammar>
      <emu-alg>
        1. Let _result_ be ? Evaluation of |Expression|.
        1. Return ToBoolean(_result_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-combined-match-pattern-matches" type="sdo">
      <h1>
        Runtime Semantics: CombinedMatchPatternMatches (
          _subject_: an ECMAScript language value,
        ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        CombinedMatchPattern : MatchPattern `and` MatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _leftMatches_ be ? MatchPatternMatches of the first |MatchPattern| with arguments _subject_.
        1. If _leftMatches_ is *false*, return *false*.
        1. Return ? MatchPatternMatches of the second |MatchPattern| with arguments _subject_.
      </emu-alg>
      <emu-grammar>
        CombinedMatchPattern : MatchPattern `or` MatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _leftMatches_ be ? MatchPatternMatches of the first |MatchPattern| with arguments _subject_.
        1. If _leftMatches_ is *true*, return *true*.
        1. Return ? MatchPatternMatches of the second |MatchPattern| with arguments _subject_.
      </emu-alg>
      <emu-grammar>
        CombinedMatchPattern : `not` MatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _matches_ be ? MatchPatternMatches of |MatchPattern| with arguments _subject_.
        1. If _matches_ is *true*, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-abstract-operations-for-pattern-matching">
    <h1>Abstract Operations for Pattern Matching</h1>

    <emu-clause id="sec-invoke-custom-matcher" type="abstract operation">
      <h1><ins>
        InvokeCustomMatcher (
          _matcher_: an ECMAScript language value,
          _subject_: an ECMAScript language value,
          _kind_: ~boolean~ or ~list~,
          _receiver_: an ECMAScript language value,
        ): either a normal completion containing either a Boolean or an Iterator Record, or an abrupt completion
      </ins></h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If _matcher_ is not an Object, return SameValueZero(_matcher_, _subject_).
        1. Let _f_ be ? Get(_matcher_, @@customMatcher).
        1. If _f_ is *undefined*, return SameValueNonNumber(_matcher_, _subject_).
        1. If _kind_ is ~boolean~, let _hint_ be *"boolean"*.
        1. Else, let _hint_ be *"list"*.
        1. Let _result_ be ? Call(_f_, _matcher_, « _subject_, _hint_, _receiver_ »).
        1. If _result_ is *false*, return *false*.
        1. If _result_ is *true* and _kind_ is ~boolean~, return *true*.
        1. If _result_ is not an Object, throw a *TypeError* exception.
        1. Let _iterator_ be ? GetIterator(_result_, ~sync~).
        1. If _kind_ is ~boolean~, then
          1. Perform ? IteratorClose(_iterator_, a normal completion with a value of unused).
          1. Return *true*.
        1. Return _iterator_.
      </emu-alg>
      <emu-note type="editor">
        The hint parameter is not a consensus in the champion group yet. This design is to solve <a href="https://github.com/tc39/proposal-pattern-matching/issues/253" target="_blank">runtime performance concerns about custom matchers</a>. The <a href="https://github.com/tc39/proposal-extractors" target="_blank">extractor proposal</a> may add a new hint ~object~ for the following syntax.
        <pre><code class="javascript">
          const Point{ x, y } = expr;
        </code></pre>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-validatecustommatcherhint" type="abstract operation">
        <h1>
            ValidateCustomMatcherHint (
                _hint_: an ECMAScript language value,
                optional _kind_: ~boolean~ or ~list~,
            ): either a normal completion containing ~unused~ or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
            1. If _hint_ is not *"boolean"* or *"list"*, throw a *TypeError* exception.
            1. If _kind_ is not present, return ~unused~.
            1. If _hint_ is *"boolean"* and _kind_ is ~list~, throw a *TypeError* exception.
            1. If _hint_ is *"list"* and _kind_ is ~boolean~, throw a *TypeError* exception.
        </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-notes">
  <h1>Editor's notes</h1>
  <emu-clause id="sec-notes-layering">
    <h1>Layering</h1>
    <p>The pattern-matching champion group designed this proposal with a layering approach. It does not mean the proposal is an MVP. The champion group wishes to ship the proposal as a whole when possible, but we can drop some features if there is strong pushback from the committee.</p>
    <p>This approach allows the champion group to consider how all features combine and also how the proposal should behave if any of the features are missing.</p>
    <p>A feature will have a note if</p>
    <ul>
      <li>it is a convenient feature instead of a necessary feature.</li>
      <li>not all champion group members represent the hope to include it.</li>
    </ul>
  </emu-clause>
  <emu-clause id="sec-notes-code-example">
    <h1>Code example</h1>
    <p>The code example in the patterns section will be in one of the forms:</p>
    <pre><code class="javascript">
      value is &lt;pattern&gt;;
      when &lt;pattern&gt;: ...,
    </code></pre>
    <p>The first form is an expression that can be used in any expression position.</p>
    <pre><code class="javascript">
      const isOk = response is { ok: true, status: &gt; 100 and &lt; 400 };
    </code></pre>
    <p>The second form is a clause of the match expression that is only available inside a match expression.</p>
    <pre><code class="javascript">
      const type = match(expr) {
        { ok: true, status: &gt; 100 and &lt; 400 }: "ok",
        { ok: false, status: 404 }: "not found",
        default: "unknown",
      };
    </code></pre>
    <p>The "when" keyword was removed, but for the readability of code examples, "when" is kept.</p>
    <p>This document prefers the `is` form unless the declaration pattern (`let x`) appears.</p>
  </emu-clause>
</emu-clause>
