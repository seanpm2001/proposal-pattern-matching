<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Pattern Matching
stage: 1
contributors:
  - Daniel Rosenwasser
  - Jack Works
  - Jordan Harband
  - Mark Cohen
  - Ross Kirsling
  - Tab Atkins
  - Yulia Startsev
</pre>

<emu-clause id="sec-match-expression">
  <h1>Match Expression</h1>
  <emu-clause id="sec-match-expression-syntax">
    <h1>Syntax</h1>
    <emu-note>Work in progress.</emu-note>
    <emu-grammar type="definition">
      MatchExpression ::
        `match` [no LineTerminator here] `(` Expression `)` [no LineTerminator here] `{` MatchClauses? `}`

      MatchClauses :
        MatchClause
        MatchClauses MatchClause

      MatchClause :
        `when` `(` MatchPattern `)` `if` `(` Expression `)` `:` Expression
        `when` `(` MatchPattern `)` `:` Expression
        `if` `(` Expression `)` `:` Expression
        `default` `:` Expression

      MatchPattern :
        CombinedMatchPattern
        InterpolationPattern
        IdentifierMatchPattern
        NearLiteralMatchPattern
        ObjectMatchPattern
        ArrayMatchPattern
        `(` MatchPattern `)`

      CombinedMatchPattern:
        MatchPattern `or` MatchPattern
        MatchPattern `and` MatchPattern

      InterpolationPattern:
        `${` Expression `}` `with` MatchPattern
        `${` Expression `}`

      IdentifierMatchPattern :
        BindingIdentifier

      NearLiteralMatchPattern :
        NullLiteral
        BooleanLiteral
        NumericLiteral
        StringLiteral
        RegularExpressionLiteral `with` MatchPattern
        RegularExpressionLiteral
        TemplateLiteral[~Tagged]
        `+` NumericLiteral
        `-` NumericLiteral
        `+` `Infinity`
        `-` `Infinity`
        `NaN`
        `+` `NaN`
        `-` `NaN`

      ObjectMatchPattern :
        `{` `}`
        `{` MatchRestProperty `}`
        `{` MatchPropertyList `}`
        `{` MatchPropertyList `,` MatchRestProperty? `}`

      ArrayMatchPattern :
        `[` Elision? MatchRestElement? `]`
        `[` MatchElementList `]`
        `[` MatchElementList `,` Elision? MatchRestElement? `]`

      MatchRestProperty :
        `...` IdentifierMatchPattern

      MatchPropertyList :
        MatchProperty
        MatchPropertyList `,` MatchProperty

      MatchElementList :
        MatchElisionElement
        MatchElementList `,` MatchElisionElement

      MatchElisionElement :
        Elision? MatchPattern

      MatchProperty :
        IdentifierMatchPattern
        PropertyName `:` MatchPattern

      MatchRestElement :
        `...` MatchPattern?

    </emu-grammar>
    <emu-note>
      `undefined`, `NaN` and `Infinity` are covered by the IdentifierMatchPattern, but `+Infinity` and `-Infinity` are coverd by the NearLiteralMatchPattern.
    </emu-note>
    <emu-note>
      No Initializer is allowed in the current syntax. See <a href="https://github.com/tc39/proposal-pattern-matching/#default-values">https://github.com/tc39/proposal-pattern-matching/#default-values</a>
    </emu-note>
  </emu-clause>
  <emu-clause id="sec-match-expression-early-errors">
    <h1>Static Semantics: Early Errors</h1>
    <emu-note>To be done.</emu-note>
    <emu-grammar>
      MatchClauses :
        MatchClause
    </emu-grammar>
    <ul>
      <li>It is a Syntax Error if ...</li>
    </ul>
  </emu-clause>
  <emu-clause id="sec-match-expression-runtime-semantics">
    <h1>Runtime Semantics: Evaluation</h1>
    <emu-grammar>
      MatchExpression ::
        `match` `(` Expression `)` `{` MatchClauses? `}`
    </emu-grammar>
    <emu-alg>
      1. Let _exprRef_ be the result of evaluating Expression.
      1. Let _matchable_ be ? GetValue(_exprRef_).
      1. If MatchClauses is not present, throw a *TypeError* exception.
      1. Let _cache_ be ! Construct(%Map%, a new Empty List).
      1. Return ? MatchClausesEvaluation of MatchClauses with argument _matchable_ and _cache_.
    </emu-alg>
  </emu-clause>
  <emu-clause id="sec-match-clauses-evaluation">
    <h1>Runtime Semantics: <dfn>MatchClausesEvaluation</dfn></h1>
    <p>The syntax-directed operation MatchClausesEvaluation takes argument _matchable_ (an ECMAScript language value) and _cache_ (a %Map%) and returns either a normal completion containing a Match Record or an abrupt completion. It is defined piecewise over the following productions:</p>
    <emu-grammar>
      MatchClauses : MatchClause
    </emu-grammar>
    <emu-alg>
      1. Let _result_ be ? MatchClauseEvaluation of MatchClause with argument _matchable_ and _cache_.
      1. If _result_.[[Matched]] is *true*, return _result_.[[Value]].
      1. Throw a *TypeError*.
    </emu-alg>
    <emu-grammar>
      MatchClauses : MatchClauses MatchClause
    </emu-grammar>
    <emu-alg>
      1. Let _result_ be ? MatchClausesEvaluation of MatchClauses with argument _matchable_ and _cache_.
      1. If _result_.[[Matched]] is *true*, return _result_.[[Value]].
      1. Let _result_ be ? MatchClauseEvaluation of MatchClause with argument _matchable_ and _cache_.
      1. If _result_.[[Matched]] is *true*, return _result_.[[Value]].
      1. Throw a *TypeError*.
    </emu-alg>
  </emu-clause>
  <emu-clause id="sec-match-clause-evaluation">
    <h1>Runtime Semantics: <dfn>MatchClauseEvaluation</dfn></h1>
    <p>The syntax-directed operation MatchClauseEvaluation takes argument _matchable_ (an ECMAScript language value) and _cache_ (a %Map%) and returns either a normal completion containing a Match Record or an abrupt completion. It is defined piecewise over the following productions:</p>
    <emu-grammar>
      MatchClause : `when` `(` MatchPattern `)` `if` `(` Expression `)` `:` Expression
    </emu-grammar>
    <emu-alg>
      1. Let _closure_ be a new Abstract Closure with parameters () that captures _matchable_, _cache_ and _MatchPattern_ and performs the following steps when called:
        1. Let _matches_ be ? MatchPatternMatches of MatchPattern with arguments _matchable_ and _cache_.
        1. If _matches_ is *false*, return Match Record { [[Matched]]: false, [[Value]]: unused }.
        1. Let _ifRef_ be the result of evaluating the first Expression.
        1. Let _ifGuard_ be ToBoolean(? GetValue(_ifRef_)).
        1. If _ifGuard_ is *false*, then
          1. return Match Record { [[Matched]]: *false*, [[Value]]: unused }.
        1. Let _exprRef_ be evaluating the second Expression.
        1. Let _exprVal_ be ? GetValue(_exprRef_).
        1. Return Match Record { [[Matched]]: *true*, [[Value]]: _exprVal_ }.
      1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
      1. Let _matchEnv_ be NewDeclarativeEnvironment(_oldEnv_).
      1. Set the running execution context's LexicalEnvironment to _matchEnv_.
      1. Let _result_ be _closure_ ().
      1. Set the running execution context's LexicalEnvironment to _oldEnv_.
      1. Return _result_.
    </emu-alg>
    <emu-grammar>
      MatchClause : `when` `(` MatchPattern `)` `:` Expression
    </emu-grammar>
    <emu-alg>
      1. Let _closure_ be a new Abstract Closure with parameters () that captures _matchable_, _cache_ and _MatchPattern_ and performs the following steps when called:
        1. Let _matches_ be ? MatchPatternMatches of MatchPattern with arguments _matchable_ and _cache_.
        1. If _matches_ is *false*, return Match Record { [[Matched]]: false, [[Value]]: unused }.
        1. Let _exprRef_ be evaluating the second Expression.
        1. Let _exprVal_ be ? GetValue(_exprRef_).
        1. Return Match Record { [[Matched]]: *true*, [[Value]]: _exprVal_ }.
      1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
      1. Let _matchEnv_ be NewDeclarativeEnvironment(_oldEnv_).
      1. Set the running execution context's LexicalEnvironment to _matchEnv_.
      1. Let _result_ be _closure_ ().
      1. Set the running execution context's LexicalEnvironment to _oldEnv_.
      1. Return _result_.
    </emu-alg>
    <emu-grammar>
      MatchClause : `if` `(` Expression `)` `:` Expression
    </emu-grammar>
    <emu-alg>
      1. Let _ifRef_ be the result of evaluating the first Expression.
      1. Let _ifGuard_ be ToBoolean(? GetValue(_ifRef_)).
      1. If _ifGuard_ is *false*, then
        1. return Match Record { [[Matched]]: *false*, [[Value]]: unused }.
      1. Let _exprRef_ be evaluating the second Expression.
      1. Let _exprVal_ be ? GetValue(_exprRef_).
      1. Return Match Record { [[Matched]]: *true*, [[Value]]: _exprVal_ }.
    </emu-alg>
    <emu-grammar>
      MatchClause : `default` `:` Expression
    </emu-grammar>
    <emu-alg>
      1. Let _exprRef_ be evaluating the Expression.
      1. Let _exprVal_ be ? GetValue(_exprRef_).
      1. Return Match Record { [[Matched]]: *true*, [[Value]]: _exprVal_ }.
    </emu-alg>
  </emu-clause>
  <emu-clause id="sec-match-pattern-matches">
    <h1>Runtime Semantics: <dfn>MatchPatternMatches</dfn></h1>
    <p>The syntax-directed operation MatchPatternMatches takes argument _matchable_ (an ECMAScript language value) and _cache_ (a %Map%) and returns either a normal completion containing a Boolean or an abrupt completion. It is defined piecewise over the following productions:</p>
    <emu-grammar>
      MatchPattern : CombinedMatchPattern
    </emu-grammar>
    <emu-alg>
      1. Return ? CombinedMatchPatternMatches of CombinedMatchPattern with arguments _matchable_ and _cache_.
    </emu-alg>
    <emu-grammar>
      MatchPattern : InterpolationPattern
    </emu-grammar>
    <emu-alg>
      1. Return ? InterpolationPatternMatches of InterpolationPattern with arguments _matchable_ and _cache_.
    </emu-alg>
    <emu-grammar>
      MatchPattern : IdentifierMatchPattern
    </emu-grammar>
    <emu-alg>
      1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
      1. Let _newEnv_ be NewDeclarativeEnvironment(_newEnv_).
      1. Set the running execution context's LexicalEnvironment to _matchEnv_.
      1. Let _identifier_ be the BindingIdentifier that is coverd by IdentifierMatchPattern.
      1. Let _name_ be the BoundNames of _identifier_.
      1. Perform ! _newEnv_.CreateImmutableBinding(_name_[0], *true*).
      1. Perform ! _newEnv_.InitializeBinding(_name_[0], _matchable_).
      1. Return *true*.
    </emu-alg>
    <emu-grammar>
      MatchPattern : NearLiteralMatchPattern
    </emu-grammar>
    <emu-alg>
      1. Return ? NearLiteralMatchPatternMatches of NearLiteralMatchPattern with arguments _matchable_ and _cache_.
    </emu-alg>
    <emu-grammar>
      MatchPattern : ObjectMatchPattern
    </emu-grammar>
    <emu-alg>
      1. Return ? ObjectMatchPatternMatches of ObjectMatchPattern with arguments _matchable_ and _cache_.
    </emu-alg>
    <emu-grammar>
      MatchPattern : ArrayMatchPattern
    </emu-grammar>
    <emu-alg>
      1. Return ? ArrayMatchPatternMatches of ArrayMatchPattern with arguments _matchable_ and _cache_.
    </emu-alg>
    <emu-grammar>
      MatchPattern : `(` MatchPattern `)`
    </emu-grammar>
    <emu-alg>
      1. Return MatchPatternMatches of MatchPattern with argument _matchable_ and _cache_.
    </emu-alg>
  </emu-clause>
  <emu-clause id="sec-combined-match-pattern-matches">
    <h1>Runtime Semantics: <dfn>CombinedMatchPatternMatches</dfn></h1>
    <p>The syntax-directed operation CombinedMatchPatternMatches takes argument _matchable_ (an ECMAScript language value) and _cache_ (a %Map%) and returns either a normal completion containing a Boolean or an abrupt completion. It is defined piecewise over the following productions:</p>
    <emu-grammar>
      CombinedMatchPattern : MatchPattern `or` MatchPattern
    </emu-grammar>
    <emu-alg>
      1. Let _leftMatches_ be MatchPatternMatches of the first MatchPattern with arguments _matchable_ and _cache_.
      1. If _leftMatches_ is *true*, return *true*.
      1. Return MatchPatternMatches of the second MatchPattern with arguments _matchable_ and _cache_.
    </emu-alg>
    <emu-grammar>
      CombinedMatchPattern : MatchPattern `and` MatchPattern
    </emu-grammar>
    <emu-alg>
      1. Let _leftMatches_ be MatchPatternMatches of the first MatchPattern with arguments _matchable_ and _cache_.
      1. If _leftMatches_ is *false*, return *false*.
      1. Return MatchPatternMatches of the second MatchPattern with arguments _matchable_ and _cache_.
    </emu-alg>
  </emu-clause>
  <emu-clause id="sec-interpolation-pattern-matches">
    <h1>Runtime Semantics: <dfn>InterpolationPatternMatches</dfn></h1>
    <p>The syntax-directed operation InterpolationPatternMatches takes argument _matchable_ (an ECMAScript language value) and _cache_ (a %Map%) and returns either a normal completion containing a Boolean or an abrupt completion. It is defined piecewise over the following productions:</p>
    <emu-grammar>
      InterpolationPattern : `${` Expression `}`
    </emu-grammar>
    <emu-alg>
      1. Let _exprRef_ be evaluating the Expression.
      1. Let _exprVal_ be ? GetValue(_exprRef_).
      1. Let _result_ be ? InvokeCustomMatcher(_exprVal_, _matchable_).
      1. If _result_ is an ECMAScript language value, return *true*.
      1. Return _result_.
    </emu-alg>
    <emu-grammar>
      InterpolationPattern : `${` Expression `}` `with` MatchPattern
    </emu-grammar>
    <emu-alg>
      1. Let _exprRef_ be evaluating the Expression.
      1. Let _exprVal_ be ? GetValue(_exprRef_).
      1. Let _result_ be ? InvokeCustomMatcher(_exprVal_, _matchable_).
      1. If _result_ is *false*, return *false*.
      1. If _result_ is an ECMAScript language value, then
        1. Let _newCache_ be ! Construct(%Map%, a new Empty List).
        1. Let _matches_ be ? MatchPatternMatches of MatchPattern with arguments _result_ and _newCache_.
        1. Return _matches_.
      1. Return ? MatchPatternMatches of MatchPattern with arguments _matchable_ and _cache_.
    </emu-alg>
  </emu-clause>
  <emu-clause id="sec-near-literal-match-pattern-matches">
    <h1>Runtime Semantics: <dfn>NearLiteralMatchPatternMatches</dfn></h1>
    <p>The syntax-directed operation NearLiteralMatchPatternMatches takes argument _matchable_ (an ECMAScript language value) and _cache_ (a %Map%) and returns either a normal completion containing a Boolean or an abrupt completion. It is defined piecewise over the following productions:</p>
    <emu-grammar>
      NearLiteralMatchPattern : NullLiteral
    </emu-grammar>
    <emu-alg>
      1. Return SameValue(_matchable_, *null*).
    </emu-alg>
    <emu-grammar>
      NearLiteralMatchPattern : BooleanLiteral
    </emu-grammar>
    <emu-alg>
      1. Return SameValue(_matchable_, the result of evaluating BooleanLiteral).
    </emu-alg>
    <emu-grammar>
      NearLiteralMatchPattern : NumericLiteral
    </emu-grammar>
    <emu-alg>
      1. Return SameValue(_matchable_, the result of evaluating NumericLiteral).
    </emu-alg>
    <emu-grammar>
      NearLiteralMatchPattern : StringLiteral
    </emu-grammar>
    <emu-alg>
      1. Return SameValue(_matchable_, the result of evaluating StringLiteral).
    </emu-alg>
    <emu-grammar>
      NearLiteralMatchPattern : RegularExpressionLiteral `with` MatchPattern
    </emu-grammar>
    <emu-alg>
      1. Let _regexp_ be the result of evaluating RegularExpressionLiteral.
      1. If Type(_matchable_) is not a String, return *false*.
      1. Let _result_ be ? RegExpBuiltinExec(_regexp_, _matchable_).
      1. If _result_ is *null*, return *false*.
      1. Let _newCache_ be ! Construct(%Map%, a new Empty List).
      1. Return ? MatchPatternMatches of MatchPattern with arguments _result_ and _newCache_.
    </emu-alg>
    <emu-grammar>
      NearLiteralMatchPattern : RegularExpressionLiteral
    </emu-grammar>
    <emu-alg>
      1. Let _regexp_ be the result of evaluating RegularExpressionLiteral.
      1. If Type(_matchable_) is not a String, return *false*.
      1. Let _result_ be ? RegExpBuiltinExec(_regexp_, _matchable_).
      1. If _result_ is *null*, return *false*.
      1. Return *true*.
    </emu-alg>
    <emu-grammar>
      NearLiteralMatchPattern : TemplateLiteral[~Tagged]
    </emu-grammar>
    <emu-alg>
      1. Return SameValue(_matchable_, the result of evaluating TemplateLiteral).
    </emu-alg>
    <emu-grammar>
      NearLiteralMatchPattern : `+` NumericLiteral
    </emu-grammar>
    <emu-alg>
      1. Let _num_ be the result of evaluating NumericLiteral.
      1. Return SameValueZero(_matchable_, _num_).
    </emu-alg>
    <emu-grammar>
      NearLiteralMatchPattern : `-` NumericLiteral
    </emu-grammar>
    <emu-alg>
      1. Let _num_ be the result of evaluating NumericLiteral.
      1. Return SameValueZero(_matchable_, -_num_).
    </emu-alg>
    <emu-grammar>
      NearLiteralMatchPattern : `+` `Infinity`
    </emu-grammar>
    <emu-alg>
      1. Return SameValue(_matchable_, *Infinity*).
    </emu-alg>
    <emu-grammar>
      NearLiteralMatchPattern : `-` `Infinity`
    </emu-grammar>
    <emu-alg>
      1. Return SameValue(_matchable_, *-Infinity*).
    </emu-alg>
    <emu-grammar>
      NearLiteralMatchPattern : `NaN`
      NearLiteralMatchPattern : `+` `NaN`
      NearLiteralMatchPattern : `-` `NaN`
    </emu-grammar>
    <emu-alg>
      1. Return SameValue(_matchable_, *NaN*).
    </emu-alg>
  </emu-clause>
  <emu-clause id="sec-match-record">
    <h1>Match Records</h1>
    <p>A Match Record is a Record value used to represent the match result of the match clause.</p>
    <p>Match Record have the fields listed in Table 1.</p>
    <emu-table>
      <emu-caption>Table 1</emu-caption>
      <table>
        <tr><th>Field Name</th><th>Value</th><th>Meaning</th></tr>
        <tr><td>[[Matched]]</td><td>a Boolean</td><td>If the match clause matched.</td></tr>
        <tr><td>[[Value]]</td><td>an ECMAScript language value</td><td>The matched value.</td></tr>
      </table>
    </emu-table>
  </emu-clause>
  <emu-clause id="sec-custom-matcher">
    <h1><dfn>InvokeCustomMatcher</dfn> ( _val_, _matchable_ )</h1>
    <p>The abstract operation GetCustomMatcher takes argument _val_ and returns a Boolean or an ECMAScript language value. It performs the following steps when called:</p>
    <emu-alg>
      1. Let _type_ be Type(_val_).
      1. If _type_ is not Object, return SameValue(_val_, _matchable_).
      1. Let _matcher_ be ? Get(_val_, @@matcher).
      1. If IsCallable(_matcher_) is *false*, throw a TypeError exception.
      1. Let _result_ be ? Call(_matcher_, *undefined*, « _matchable_ »).
      1. If Type(_result_) is not Object, throw a TypeError exception.
      1. Let _matched_ be ToBoolean(? Get(_result_, *"matched"*)).
      1. If _matched_ is *false*, return *false*.
      1. Return ? Get(_result_, *"value"*).
    </emu-alg>
  </emu-clause>
</emu-clause>
