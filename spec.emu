<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Pattern Matching
stage: 1
contributors:
  - Daniel Rosenwasser
  - Jack Works
  - Jordan Harband
  - Mark Cohen
  - Ross Kirsling
  - Tab Atkins
</pre>
<style>
  emu-note[code] > .note {
    font-size: 0;
  }
  emu-note[code] > .note::before {
    content: "Example";
    font-size: 18px;
  }
  emu-note[code] pre {
    margin: 0;
  }
  pre.inline {
    display: inline;
  }
  pre.inline code {
    display: inline;
    font-style: italic;
    text-decoration: underline;
  }
</style>

<p>Work in progress. Before continuing, please read the&nbsp;<emu-xref href="#sec-notes" title></emu-xref>.</p>
<emu-clause id="sec-pattern-matching" number="30">
  <h1><ins>Pattern Matching</ins></h1>

  <emu-clause id="sec-match-patterns">
    <h1>Match Patterns</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      MatchPattern[Yield, Await] :
        `(` MatchPattern[?Yield, ?Await] `)`
        PrimitivePattern
        MemberExpressionPattern[?Yield, ?Await]
        UnaryAlgebraicPattern[?Yield, ?Await]
        CombinedMatchPattern[?Yield, ?Await]
    </emu-grammar>

    <!-- #region PrimitivePattern -->
    <emu-grammar type="definition">
      PrimitivePattern :
        Literal
        NoSubstitutionTemplate
    </emu-grammar>
    <emu-note code>
      <pre><code class="javascript">
        value is null;
        value is true;
        value is 1_000_000;
        value is "string";
        value is `line 1
        line 2`;
      </code></pre>
    </emu-note>
    <emu-note type="editor">
      Preserve the interpolation syntax for (1) <a href="https://github.com/tc39/proposal-pattern-matching/pull/293#discussion_r1350757767" target="_blank">concerns about arbitrary expression interpolation</a> and (2) <a target="_blank" href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#inference-with-template-literals">intuitive string matching</a>.
      For example, match `"com.example:method()"` by
      <pre><code class="javascript">
        when `${isPackageName and let pkg}:${isIdentifier and let method}()`: ...,
      </code></pre>
    </emu-note>
    <!-- endregion -->

    <!-- #region MemberExpressionPattern -->
    <emu-grammar type="definition">
      MemberExpressionPattern[Yield, Await] :
        PatternMatchingMemberExpression[?Yield, ?Await]

      PatternMatchingMemberExpression[Yield, Await] :
        IdentifierReference[?Yield, ?Await]
        MemberExpressionPattern[?Yield, ?Await] `.` IdentifierName
    </emu-grammar>
    <emu-note code>
      <pre><code class="javascript">
        value is undefined;
        value is Math.PI;
      </code></pre>
    </emu-note>
    <emu-note type="editor">
      The |MemberExpressionPattern| `.` |IdentifierName| production is removable.
      <pre><code class="javascript">
        value is Math.PI;
        // can be written as:
        const { PI } = Math;
        value is PI;
      </code></pre>
      It is similar to the <a href="https://tc39.es/proposal-decorators/#sec-new-syntax" target="_blank">DecoratorMemberExpression</a>.<br />
      Should we allow `MemberExpressionPattern[expr]` to match with computed property names?<br />
      Should we cache the `[[Get]]` call as we do in the object match patterns?
    </emu-note>
    <!-- endregion -->

    <!-- #region UnaryAlgebraicPattern -->
    <emu-grammar type="definition">
      UnaryAlgebraicPattern[Yield, Await] :
        `+` PatternMatchingMemberExpression[?Yield, ?Await]
        `-` PatternMatchingMemberExpression[?Yield, ?Await]
        `+` NumericLiteral
        `-` NumericLiteral
    </emu-grammar>
    <emu-note code>
      <pre><code class="javascript">
        value is -0; // not matching `+0` and vice versa
        value is -Infinity;
        value is -Math.PI;
      </code></pre>
    </emu-note>
    <emu-note type="editor">
      This production is removable, but it will be harder to handle with `+0` and `-0`.
      <pre><code class="javascript">
        value is -Infinity;
        // can be written as:
        const negInf = -Infinity;
        value is negInf;
      </code></pre>
    </emu-note>
    <!-- endregion -->

    <!-- #region CombinedMatchPattern -->
    <emu-grammar type="definition">
      CombinedMatchPattern[Yield, Await] :
        MatchPattern[?Yield, ?Await] `and` MatchPattern[?Yield, ?Await]
        MatchPattern[?Yield, ?Await] `or` MatchPattern[?Yield, ?Await]
        `not` MatchPattern[?Yield, ?Await]
    </emu-grammar>
    <emu-note code>
      <pre><code class="javascript">
        value is not 0;
        value is "true" or "yes";
      </code></pre>
    </emu-note>
    <!-- endregion -->

    <emu-clause id="sec-match-patterns-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>
        CombinedMatchPattern :
          MatchPattern `and` MatchPattern
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if either of |MatchPattern| is a |CombinedMatchPattern| and does not match this production.</li>
      </ul>
      <emu-grammar>
        CombinedMatchPattern :
          MatchPattern `or` MatchPattern
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if either of |MatchPattern| is a |CombinedMatchPattern| and does not match this production.</li>
      </ul>
      <emu-grammar>
        CombinedMatchPattern :
          `not` MatchPattern
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if the |MatchPattern| is a |CombinedMatchPattern|.</li>
      </ul>
      <emu-note code><pre><code class="javascript">
        value is a and b and c; // no Syntax Error
        value is a or b or c; // no Syntax Error

        value is a and b or c; // Syntax Error
        value is (a and b) or c; // no Syntax Error
        value is a and (b or c); // no Syntax Error

        value is not not a; // Syntax Error
        value is not (not a); // no Syntax Error

        value is not a or b; // Syntax Error
        value is not (a or b); // no Syntax Error
      </code></pre></emu-note>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-match-pattern-semantics">
    <h1>Match Pattern Semantics</h1>

    <emu-clause id="sec-match-pattern-matches" type="sdo">
      <h1>
        Runtime Semantics: MatchPatternMatches (
          _subject_: an ECMAScript language value,
        ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        MatchPattern : `(` MatchPattern `)`
      </emu-grammar>
      <emu-alg>
        1. Return ? MatchPatternMatches of |MatchPattern| with arguments _subject_.
      </emu-alg>
      <emu-grammar>
        MatchPattern : PrimitivePattern
      </emu-grammar>
      <emu-alg>
        1. Return PrimitivePatternMatches of |PrimitivePattern| with arguments _subject_.
      </emu-alg>
      <emu-grammar>
        MatchPattern : MemberExpressionPattern
      </emu-grammar>
      <emu-alg>
        1. Return ? MemberExpressionPatternMatches of |MemberExpressionPattern| with arguments _subject_.
      </emu-alg>
      <emu-grammar>
        MatchPattern : UnaryAlgebraicPattern
      </emu-grammar>
      <emu-alg>
        1. Return ? UnaryAlgebraicPatternMatches of |UnaryAlgebraicPattern| with arguments _subject_.
      </emu-alg>
      <emu-grammar>
        MatchPattern : CombinedMatchPattern
      </emu-grammar>
      <emu-alg>
        1. Return ? CombinedMatchPatternMatches of |CombinedMatchPattern| with arguments _subject_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-primitive-pattern-matches" type="sdo">
      <h1>
        Runtime Semantics: PrimitivePatternMatches (
          _subject_: an ECMAScript language value,
        ): a Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        PrimitivePattern : Literal
      </emu-grammar>
      <emu-alg>
        1. Return SameValueZero(_subject_, ! Evaluation of |Literal|).
      </emu-alg>
      <emu-grammar>
        PrimitivePattern : NoSubstitutionTemplate
      </emu-grammar>
      <emu-alg>
        1. Return SameValueNonNumber(_subject_, ! Evaluation of |NoSubstitutionTemplate|).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-member-expression-pattern-matches" type="sdo">
      <h1>
        Runtime Semantics: MemberExpressionPatternMatches (
          _subject_: an ECMAScript language value,
        ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        MemberExpressionPattern : PatternMatchingMemberExpression
      </emu-grammar>
      <emu-alg>
        1. Let _expr_ be the |MemberExpression| that is covered by |PatternMatchingMemberExpression|.
        1. Let _ref_ be ? Evaluation of _expr_.
        1. Let _value_ be ? GetValue(_ref_).
        1. Return SameValueZero(_subject_, _value_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-unary-algebraic-pattern-matches" type="sdo">
      <h1>
        Runtime Semantics: UnaryAlgebraicPatternMatches (
          _subject_: an ECMAScript language value,
        ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        UnaryAlgebraicPattern
      </emu-grammar>
      <emu-alg>
        1. Let _expr_ be the |MemberExpression| that is covered by |UnaryAlgebraicPattern|.
        1. Let _ref_ be ? Evaluation of _expr_.
        1. Let _value_ be ? GetValue(_ref_).
        1. Return SameValue(_subject_, _value_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-combined-match-pattern-matches" type="sdo">
      <h1>
        Runtime Semantics: CombinedMatchPatternMatches (
          _subject_: an ECMAScript language value,
        ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        CombinedMatchPattern : MatchPattern `and` MatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _leftMatches_ be ? MatchPatternMatches of the first |MatchPattern| with arguments _subject_.
        1. If _leftMatches_ is *false*, return *false*.
        1. Return ? MatchPatternMatches of the second |MatchPattern| with arguments _subject_.
      </emu-alg>
      <emu-grammar>
        CombinedMatchPattern : MatchPattern `or` MatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _leftMatches_ be ? MatchPatternMatches of the first |MatchPattern| with arguments _subject_.
        1. If _leftMatches_ is *true*, return *true*.
        1. Return ? MatchPatternMatches of the second |MatchPattern| with arguments _subject_.
      </emu-alg>
      <emu-grammar>
        CombinedMatchPattern : `not` MatchPattern
      </emu-grammar>
      <emu-alg>
        1. Let _matches_ be ? MatchPatternMatches of |MatchPattern| with arguments _subject_.
        1. If _matches_ is *true*, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-abstract-operations-for-pattern-matching">
    <h1>Abstract Operations for Pattern Matching</h1>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-notes">
  <h1>Editor's notes</h1>
  <emu-clause id="sec-notes-layering">
    <h1>Layering</h1>
    <p>The pattern-matching champion group designed this proposal with a layering approach. It does not mean the proposal is an MVP. The champion group wishes to ship the proposal as a whole when possible, but we can drop some features if there is strong pushback from the committee.</p>
    <p>This approach allows the champion group to consider how all features combine and also how the proposal should behave if any of the features are missing.</p>
    <p>A feature will have a note if</p>
    <ul>
      <li>it is a convenient feature instead of a necessary feature.</li>
      <li>not all champion group members represent the hope to include it.</li>
    </ul>
  </emu-clause>
  <emu-clause id="sec-notes-code-example">
    <h1>Code example</h1>
    <p>The code example in the patterns section will be in one of the forms:</p>
    <pre><code class="javascript">
      value is &lt;pattern&gt;;
      when &lt;pattern&gt;: ...,
    </code></pre>
    <p>The first form is an expression that can be used in any expression position.</p>
    <pre><code class="javascript">
      const isOk = response is { ok: true, status: &gt; 100 and &lt; 400 };
    </code></pre>
    <p>The second form is a clause of the match expression that is only available inside a match expression.</p>
    <pre><code class="javascript">
      const type = match(expr) {
        { ok: true, status: &gt; 100 and &lt; 400 }: "ok",
        { ok: false, status: 404 }: "not found",
        default: "unknown",
      };
    </code></pre>
    <p>The "when" keyword was removed, but for the readability of code examples, "when" is kept.</p>
    <p>This document prefers the `is` form unless the declaration pattern (`let x`) appears.</p>
  </emu-clause>
</emu-clause>
