<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Pattern Matching
stage: 1
contributors:
  - Daniel Rosenwasser
  - Jack Works
  - Jordan Harband
  - Mark Cohen
  - Ross Kirsling
  - Tab Atkins
</pre>
<style>
  emu-note[code] > .note {
    font-size: 0;
  }
  emu-note[code] > .note::before {
    content: "Example";
    font-size: 18px;
  }
  emu-note[code] pre {
    margin: 0;
  }
</style>

<p>Work in progress. Before continuing, please read the&nbsp;<emu-xref href="#sec-notes" title></emu-xref>.</p>
<emu-clause id="sec-pattern-matching" number="30">
  <h1><ins>Pattern Matching</ins></h1>

  <emu-clause id="sec-match-patterns">
    <h1>Match Patterns</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      MatchPattern :
        PrimitivePattern
    </emu-grammar>

    <emu-grammar type="definition">
      PrimitivePattern :
        Literal
        NoSubstitutionTemplate
    </emu-grammar>
    <emu-note code>
      <pre><code class="javascript">
        value is null;
        value is true;
        value is 1_000_000;
        value is "string";
        value is `line 1
        line 2`;
      </code></pre>
    </emu-note>
    <emu-note type="editor">
      Preserve the interpolation syntax for (1) <a href="https://github.com/tc39/proposal-pattern-matching/pull/293#discussion_r1350757767" target="_blank">concerns about arbitrary expression interpolation</a> and (2) <a target="_blank" href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#inference-with-template-literals">intuitive string matching</a>.
      For example, match `"com.example:method()"` by
      <pre><code class="javascript">
        when `${isPackageName and let pkg}:${isIdentifier and let method}()`: ...,
      </code></pre>
    </emu-note>
  </emu-clause>
  <emu-clause id="sec-match-pattern-semantics">
    <h1>Match Pattern Semantics</h1>

    <emu-clause id="sec-match-pattern-matches" type="sdo">
      <h1>
        Runtime Semantics: MatchPatternMatches (
          _subject_: an ECMAScript language value,
        ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        MatchPattern : PrimitivePattern
      </emu-grammar>
      <emu-alg>
        1. Return PrimitivePatternMatches of |PrimitivePattern| with arguments _subject_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-primitive-pattern-matches" type="sdo">
      <h1>
        Runtime Semantics: PrimitivePatternMatches (
          _subject_: an ECMAScript language value,
        ): a Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        PrimitivePattern : Literal
      </emu-grammar>
      <emu-alg>
        1. Return SameValue(_subject_, ! Evaluation of |Literal|).
      </emu-alg>
      <emu-grammar>
        PrimitivePattern : NoSubstitutionTemplate
      </emu-grammar>
      <emu-alg>
        1. Return SameValue(_subject_, ! Evaluation of |NoSubstitutionTemplate|).
      </emu-alg>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-abstract-operations-for-pattern-matching">
    <h1>Abstract Operations for Pattern Matching</h1>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-notes">
  <h1>Editor's notes</h1>
  <emu-clause id="sec-notes-layering">
    <h1>Layering</h1>
    <p>The pattern-matching champion group designed this proposal with a layering approach. It does not mean the proposal is an MVP. The champion group wishes to ship the proposal as a whole when possible, but we can drop some features if there is strong pushback from the committee.</p>
    <p>This approach allows the champion group to consider how all features combine and also how the proposal should behave if any of the features are missing.</p>
    <p>A feature will have a note if</p>
    <ul>
      <li>it is a convenient feature instead of a necessary feature.</li>
      <li>not all champion group members represent the hope to include it.</li>
    </ul>
  </emu-clause>
  <emu-clause id="sec-notes-code-example">
    <h1>Code example</h1>
    <p>The code example in the patterns section will be in one of the forms:</p>
    <pre><code class="javascript">
      value is &lt;pattern&gt;;
      when &lt;pattern&gt;: ...,
    </code></pre>
    <p>The first form is an expression that can be used in any expression position.</p>
    <pre><code class="javascript">
      const isOk = response is { ok: true, status: &gt; 100 and &lt; 400 };
    </code></pre>
    <p>The second form is a clause of the match expression that is only available inside a match expression.</p>
    <pre><code class="javascript">
      const type = match(expr) {
        { ok: true, status: &gt; 100 and &lt; 400 }: "ok",
        { ok: false, status: 404 }: "not found",
        default: "unknown",
      };
    </code></pre>
    <p>The "when" keyword was removed, but for the readability of code examples, "when" is kept.</p>
    <p>This document prefers the `is` form unless the declaration pattern (`let x`) appears.</p>
  </emu-clause>
</emu-clause>
